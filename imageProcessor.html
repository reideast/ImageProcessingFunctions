<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>07 image proc</title>
    <style>
        td {
            vertical-align: top;
        }

        .matrix {
            border-spacing: 0;
            border-collapse: collapse;
        }
        .matrix tr, .matrix td, .matrix input {
            margin: 0;
            padding: 0;
        }
        .matrix td {
            border: 1px solid #555;
        }
        .matrix input, .filler {
            border: 0;
            text-align: center;
            width: 24px;
            height: 24px;
        }
        td.filler {
            border: 0;
        }
        td.spacer {
            border: 0;
            width: 12px;
            text-align: center;
            vertical-align: middle;
        }
        /* .matrix tr:not(:last-child) td {
            border-bottom: 1px solid;
        }
        .matrix td:not(:last-child) {
            border-right: 1px solid;
        } */
        .opContainer input[type=range] {
            width: 60px;
            margin: 0;
        }
     </style>
</head>
<body>
<table>
    <tr>
        <td>
            <input type="file" id="filename">
            <button id="reloadButton" style="display: none;">[load]</button>
            <button id="loadDefaultImageButton" style="display: inline-block;">[load]</button>
            <button id="saveImageData" disabled style="display: inline-block;">Save</button>
        </td>
    </tr>
    <tr>
        <td id="undoBufferOperations">
            <button id="undoButton" style="display: inline-block">Undo</button>
            <button id="redoButton" style="display: inline-block">Redo</button>
            <span id="lastOp"></span>
        </td>
    </tr>
    <tr>
        <td id="canvasArea">
            <canvas id="imgCanvas" style="border: 6px solid #555" width="500" height="500"></canvas>
        </td>
    </tr>
    <tr>
        <td class="opContainer" id="globalPixelOperations">
            <button onclick="noBlue()">No Blue</button>
            <button onclick="greyscale()">Greyscale</button>
            <button onclick="invert()">Invert</button>
            <input id="threshold" type="text" size="3" value="127">
            <button onclick="threshold(parseInt(document.getElementById('threshold').value))">Threshold</button>
        </td>
    </tr>
    <tr>
        <td class="opContainer morphologicalOperations">
            <input id="sliderStructuringElem" type="range" min="2" max="50" step="1" value="5">
            <input id="structuringElementSize" size="2" value="5">
            <button onclick="erode()">Erode</button>
            <button onclick="dilate()">Dilate</button>
            <button onclick="opening()">Opening</button>
            <button onclick="closing()">Closing</button>
        </td>
    </tr>
    <!--<tr>-->
        <!--<td class="opContainer" id="edgeDetectOperations">-->
            <!--&lt;!&ndash; TODO &ndash;&gt;-->
            <!--<button onclick="sobel()">Apply Sobel 3x3</button>-->
            <!--&lt;!&ndash; TODO &ndash;&gt;-->
            <!--<button onclick="compass()">Get Compass Magnitude</button>-->
            <!--&lt;!&ndash; TODO: Some sort of colour scale to represent the 8 cardinal directions? &ndash;&gt;-->
            <!--<button onclick="compass()">Get Compass Direction</button>-->
            <!--&lt;!&ndash; TODO &ndash;&gt;-->
            <!--<button onclick="canny()">Apply Canny Algorithm</button>-->
        <!--</td>-->
    <!--</tr>-->
    <tr>
        <td class="opContainer" id="convolutionOperations">
            <table>
                <tr>
                    <td>
                        <button onclick="convolutionThree()">Apply 3x3</button>
                    </td>
                    <td>
                        <button onclick="convolutionFive()">Apply 5x5</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <table class="matrix" id="convolutionMatrix3x3">
                            <!--tr*3>td*3>input[type=text size=1].convThree#convThree$-->
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convThree" id="convThree00"></td>
                                <td><input type="text" class="convThree" id="convThree01"></td>
                                <td><input type="text" class="convThree" id="convThree02"></td>
                            </tr>
                            <tr>
                                <td><input type="text" id="factorConvThree"></td>
                                <td class="spacer">&times;</td>

                                <td><input type="text" class="convThree" id="convThree03"></td>
                                <td><input type="text" class="convThree" id="convThree04"></td>
                                <td><input type="text" class="convThree" id="convThree05"></td>
                            </tr>
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convThree" id="convThree06"></td>
                                <td><input type="text" class="convThree" id="convThree07"></td>
                                <td><input type="text" class="convThree" id="convThree08"></td>
                            </tr>
                        </table>
                    </td>
                    <td>
                        <table class="matrix" id="convolutionMatrix5x5">
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convFive" id="convFive00"></td>
                                <td><input type="text" class="convFive" id="convFive01"></td>
                                <td><input type="text" class="convFive" id="convFive02"></td>
                                <td><input type="text" class="convFive" id="convFive03"></td>
                                <td><input type="text" class="convFive" id="convFive04"></td>
                            </tr>
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convFive" id="convFive05"></td>
                                <td><input type="text" class="convFive" id="convFive06"></td>
                                <td><input type="text" class="convFive" id="convFive07"></td>
                                <td><input type="text" class="convFive" id="convFive08"></td>
                                <td><input type="text" class="convFive" id="convFive09"></td>
                            </tr>
                            <tr>
                                <td><input type="text" id="factorConvFive"></td>
                                <td class="spacer">&times;</td>

                                <td><input type="text" class="convFive" id="convFive10"></td>
                                <td><input type="text" class="convFive" id="convFive11"></td>
                                <td><input type="text" class="convFive" id="convFive12"></td>
                                <td><input type="text" class="convFive" id="convFive13"></td>
                                <td><input type="text" class="convFive" id="convFive14"></td>
                            </tr>
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convFive" id="convFive15"></td>
                                <td><input type="text" class="convFive" id="convFive16"></td>
                                <td><input type="text" class="convFive" id="convFive17"></td>
                                <td><input type="text" class="convFive" id="convFive18"></td>
                                <td><input type="text" class="convFive" id="convFive19"></td>
                            </tr>
                            <tr>
                                <td class="filler"></td>
                                <td class="spacer"></td>

                                <td><input type="text" class="convFive" id="convFive20"></td>
                                <td><input type="text" class="convFive" id="convFive21"></td>
                                <td><input type="text" class="convFive" id="convFive22"></td>
                                <td><input type="text" class="convFive" id="convFive23"></td>
                                <td><input type="text" class="convFive" id="convFive24"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button onclick="autoInputMatrix('', '1/9', '1/9', '1/9', '1/9', '1/9', '1/9', '1/9', '1/9', '1/9')">Blur</button>
                        <br>
                        <button onclick="autoInputMatrix('', -1, -1, -1, 2, 2, 2, -1, -1, -1)">Horizontal Edge</button>
                        <br>
                        <button onclick="autoInputMatrix('', -1, 2, -1, -1, 2, -1, -1, 2, -1)">Vertical Edge</button>
                        <br>
                        <button onclick="autoInputMatrix('', -1, -1, -1, -1, 8, -1, -1, -1, -1)">Laplacian Edge</button>
                        <br>
                        <button onclick="autoInputMatrix('1/4', -1, 0, 1, -2, 0, 2, -1, 0, 1)">Sobel Horizontal Edge</button>
                        <br>
                        <button onclick="autoInputMatrix('1/4', 1, 2, 1, 0, 0, 0, -1, -2, -1)">Sobel Vertical Edge</button>
                        <br>
                    </td>
                    <td>
                        <button onclick="autoInputMatrix('', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25', '1/25')">Blur</button>
                        <br>
                        <button onclick="autoInputMatrix('1/159', 2, 4, 5, 4, 2, 4, 9, 12, 9, 4, 5, 12, 15, 12, 5, 4, 9, 12, 9, 4, 2, 4, 5, 4, 2)">Gaussian Blur (StdDev=1.4px)</button>
                        <br>
                        <button onclick="autoInputMatrix('', 0, 0, 1, 0, 0, 0, 1, 2, 1, 0, 1, 2, -16, 2, 1, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0)">Laplacian of Gaussian</button>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
</table>

<script>
    // **************************************************************************
    // Globals
    // **************************************************************************

    const canvas = document.getElementById('imgCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let isGreyscale = false;
    let isBinary = false;

    // **************************************************************************
    // DOM Setup
    // **************************************************************************

    function connectSliderToText(sliderId, textId) {
        // DEBUG: Not yet sure that this will work w/ multiple sliders/text boxes (because of closure scoping)
        let sliderEl = document.getElementById(sliderId);
        let textEl = document.getElementById(textId);
        sliderEl.addEventListener("input", (event) => {
            textEl.value = event.target.value;
        });
        textEl.addEventListener("input", (event) => {
            sliderEl.value = parseInt(event.target.value);
        });
    }

    connectSliderToText("sliderStructuringElem", "structuringElementSize");

</script>
<script src="functionsLoadImage.js"></script>
<script src="functionsUndoBuffer.js"></script>
<script>
    // **************************************************************************
    // Image Processing Functions
    // **************************************************************************

    function get() {
        if (isImageLoaded) {
            return ctx.getImageData(0, 0, width, height);
        } else {
            console.error('Image not loaded yet');
            throw 'Image not loaded yet';  // Kills calling function
        }
    }

    function loopEachPixel(imgData, pixelProc, callback) {
        for (let y = 0; y < imgData.height; ++y) {
            for (let x = 0; x < imgData.width; ++x) {
                let i = (y * imgData.width + x) * 4;
                pixelProc(i, x, y);
            }
        }
        callback();
    }

    function  loopKernel(kernelSize, imgData, beforeEachKernel, kernelPixelProc, afterEachKernel, callback) {
        let kernelBorderSize = Math.floor(kernelSize / 2);
        for (let y = kernelBorderSize; y < imgData.height - kernelBorderSize; ++y) {
            for (let x = kernelBorderSize; x < imgData.width - kernelBorderSize; ++x) {
                let kernelCenterIndex = ((y * imgData.width) + x) * 4;
                beforeEachKernel(kernelCenterIndex);
                for (let yy = -kernelBorderSize; yy <= kernelBorderSize; ++yy) {
                    for (let xx = -kernelBorderSize; xx <= kernelBorderSize; ++xx) {
                        let i = ((y + yy) * imgData.width + (x + xx)) * 4;
                        let kernelCellIndex = ((yy + kernelBorderSize) * kernelSize) + (xx + kernelBorderSize);
                        kernelPixelProc(i, kernelCellIndex);
                    }
                }
                afterEachKernel(kernelCenterIndex);
            }
        }
        callback();
    }

    function noBlue() {
        const imgData = get();
        loopEachPixel(imgData, (i) => {
            imgData.data[i + 2] = 0;
        }, () => {
            ctx.putImageData(imgData, 0, 0);
            isGreyscale = isBinary = false;
            saveOp('Remove Blue');
        });
    }

    function greyscale() {
        const imgData = get();
        greyscaleProcessor(imgData, (greyscaleImageData) => {
            ctx.putImageData(greyscaleImageData, 0, 0);
            isGreyscale = true;
            isBinary = false;  // This won't be true if the image was already binary. However, it has been deemed not worth the expense to actually compute if it's truly still binary.
            saveOp('Greyscale');
        });
    }

    function greyscaleProcessor(imgData, callback) {
        loopEachPixel(imgData, (i) => {
            const avgRGB = (imgData.data[i + 0] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
            imgData.data[i + 0] = imgData.data[i + 1] = imgData.data[i + 2] = avgRGB;
        }, () => callback(imgData));
    }

    function threshold(level) {
        const imgData = get();
        // TODO: Should threshold ALWAYS greyscale first? Shouldn't the user get to specify?
        greyscaleProcessor(imgData, (greyscaleImageData) => {
            // TODO: to avoid callback chaining, convert everything to promises, or maybe async
            thresholdProcessor(level, greyscaleImageData, (thresholdImageData) => {
                ctx.putImageData(thresholdImageData, 0, 0);
                isBinary = isGreyscale = true;
                saveOp('Threshold ' + level);
            });
        });
    }

    function thresholdProcessor(level, imgData, callback) {
        loopEachPixel(imgData, (i) => {
            if (imgData.data[i + 0] >= level) {
                imgData.data[i + 0] = imgData.data[i + 1] = imgData.data[i + 2] = 255;
            } else {
                imgData.data[i + 0] = imgData.data[i + 1] = imgData.data[i + 2] = 0;
            }
        }, () => callback(imgData));
    }

    function invert() {
        const imgData = get();
        invertProcessor(imgData, (invertedData) => {
            ctx.putImageData(invertedData, 0, 0);
            // Doesn't change greyscale one way or another
            saveOp('Invert');
        });
    }

    function invertProcessor(imgData, callback) {
        loopEachPixel(imgData, (i) => {
            imgData.data[i + 0] = 255 - imgData.data[i + 0];
            imgData.data[i + 1] = 255 - imgData.data[i + 1];
            imgData.data[i + 2] = 255 - imgData.data[i + 2];
        }, () => callback(imgData));
    }

    function convolutionThree() {
        let {kernel, factor} = readConvolutionMatrixArray("convThree", "factorConvThree");
        console.log(kernel, factor);
        convolutionProcessor(3, kernel, factor, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            // Doesn't change greyscale one way or another (as I've chosen to defined it, I let convolution work on all 3 colours)
            saveOp("Convolution 3x3");
            console.log("Was modified? " + wasModified);
        })
    }

    function convolutionFive() {
        let {kernel, factor} = readConvolutionMatrixArray("convFive", "factorConvFive");
        console.log(kernel, factor);
        convolutionProcessor(5, kernel, factor, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            // Doesn't change greyscale one way or another (as I've chosen to defined it, I let convolution work on all 3 colours)
            saveOp("Convolution 5x5");
            console.log("Was modified? " + wasModified);
        })
    }

    function convolutionProcessor(convolutionSize, kernel, factor, imgData, callback) {
        if (factor === undefined) {
            factor = 1;
        }

        let newImageData = cloneImageData(imgData);

        let anyModified = false;
        let redSum, greenSum, blueSum;
        loopKernel(convolutionSize, imgData, () => {
            redSum = blueSum = greenSum = 0.0;
        }, (i, kernelCellIndex) => {
            redSum += imgData.data[i + 0] * kernel[kernelCellIndex];
            greenSum += imgData.data[i + 1] * kernel[kernelCellIndex];
            blueSum += imgData.data[i + 2] * kernel[kernelCellIndex];
        }, (centerIndex) => {
            newImageData.data[centerIndex + 0] = parseInt(redSum) * factor;
            newImageData.data[centerIndex + 1] = parseInt(greenSum) * factor;
            newImageData.data[centerIndex + 2] = parseInt(blueSum) * factor;
            if (imgData.data[centerIndex + 0] !== newImageData.data[centerIndex + 0]
                || imgData.data[centerIndex + 1] !== newImageData.data[centerIndex + 1]
                || imgData.data[centerIndex + 2] !== newImageData.data[centerIndex + 2]) {
                anyModified = true;
            }
        }, () => {
            callback(newImageData, anyModified);
        });
    }

    function parseFloatOrFraction(value) {
        let divisionSymbolPos, num;
        if ((divisionSymbolPos = value.indexOf('/')) !== -1) {
            // Process fractions like "1/9"
            num = parseFloat(value.slice(0, divisionSymbolPos)) / parseFloat(value.slice(divisionSymbolPos + 1));
        } else {
            num = parseFloat(value);
        }
        if (Number.isNaN(num)) {
            throw 'Value for convolution \'' + value + '\' could not be parsed as a number';
        }
        return num;
    }

    function readConvolutionMatrixArray(inputElemClass, factorElemId) {
        const inputs = document.getElementsByClassName(inputElemClass);
        let kernel = [];
        let num, value;
        for (let i = 0; i < inputs.length; ++i) {
            value = inputs[i].value;
            num = parseFloatOrFraction(value);
            kernel.push(num);
        }

        let factor = undefined;
        const factorInputValue = document.getElementById(factorElemId).value;
        if (factorInputValue.length !== 0) {
            factor = parseFloatOrFraction(factorInputValue);
        }

        return {kernel: kernel, factor: factor};
    }

    function autoInputMatrix(factor, ...matrixCells) {
        let matrixTextBoxes;
        switch (matrixCells.length) {
            case 9:
                document.getElementById("factorConvThree").value = factor;
                matrixTextBoxes = document.getElementsByClassName("convThree");
                break;
            case 25:
                document.getElementById("factorConvFive").value = factor;
                matrixTextBoxes = document.getElementsByClassName("convFive");
                break;
            default:
                throw 'Wrong number of matrix cells to put into text boxes: ' + matrixCells.length;
        }

        for (let i = 0; i < matrixTextBoxes.length; ++i) {
            matrixTextBoxes[i].value = matrixCells[i].toString();
        }
    }

    function cloneImageData(imgData) {
        let newImageData = new ImageData(imgData.width, imgData.height);
        for (let i = 0; i < imgData.data.length; ++i) {
            newImageData.data[i] = imgData.data[i];  // Clone each pixel's 4 color elements
        }
        return newImageData;
    }

    function erode() {
        let windowSize = parseInt(document.getElementById("structuringElementSize").value);
        erodeProcessor(windowSize, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            isBinary = isGreyscale = true;  // Image is now binary after morphological processing
            saveOp('Erode ' + windowSize + 'x' + windowSize + '');
            console.log('Was modified? ' + wasModified);
        });
    }

    // TODO: These filters will break on odd-sized kernels, since loopKernel() is set up that way
    // TODO:     Or will it? double check example
    /**
     * Perform erosion, using a square structuring element
     * Note: Using WHITE as the foreground colour for all morphological processing
     * @param structuringElementSize Width of square
     * @param imgData Canvas image data
     * @param callback Operation to perform when the image is completely processed
     */
    function erodeProcessor(structuringElementSize, imgData, callback) {
        if (!isBinary) {
            console.warn('Morphological operation performed on image that has not been thresholded first, and may not have been binary.');
            alert('Morphological operations are not meaningful on non-binary (i.e. not pure black & white) images.\n\n'
                + 'Only the red channel will be used and preserved.\n\n'
                + 'Consider reversing the changes and performing a threshold first.');
        }

        let newImageData = cloneImageData(imgData);

        let anyModified = false;
        let allPixelsForeground;
        loopKernel(structuringElementSize, imgData, () => {
            allPixelsForeground = true;
        }, (i) => {
            if (imgData.data[i] !== 255) {
                allPixelsForeground = false;
            }
        }, (centerIndex) => {
            // TODO: Is it erroneous to be subtracting the pixels if the filter doesn't pass?
            newImageData.data[centerIndex + 0] = newImageData.data[centerIndex + 1] = newImageData.data[centerIndex + 2]
                = (allPixelsForeground ? 255 : 0);
            if (imgData.data[centerIndex + 0] !== newImageData.data[centerIndex + 0]) {
                anyModified = true;
            }
        }, () => {
            callback(newImageData, anyModified);
        });
    }

    function dilate() {
        let windowSize = parseInt(document.getElementById("structuringElementSize").value);
        dilateProcessor(windowSize, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            isBinary = isGreyscale = true;  // Image is now binary after morphological processing
            saveOp('Dilate ' + windowSize + 'x' + windowSize + '');
            console.log('Was modified? ' + wasModified);
        });
    }

    function dilateProcessor(structuringElementSize, imgData, callback) {
        if (!isBinary) {
            console.warn('Morphological operation performed on image that has not been thresholded first, and may not have been binary.');
            alert('Morphological operations are not meaningful on non-binary (i.e. not pure black & white) images.\n\n'
                + 'Only the red channel will be used and preserved.\n\n'
                + 'Consider reversing the changes and performing a threshold first.');
        }

        let newImageData = cloneImageData(imgData);

        let anyModified = false;
        let anyPixelsForeground;
        loopKernel(structuringElementSize, imgData, () => {
            anyPixelsForeground = false;
        }, (i) => {
            if (imgData.data[i] === 255) {
                anyPixelsForeground = true;
            }
        }, (centerIndex) => {
            newImageData.data[centerIndex + 0] = newImageData.data[centerIndex + 1] = newImageData.data[centerIndex + 2]
                = (anyPixelsForeground ? 255 : 0);
            if (imgData.data[centerIndex + 0] !== newImageData.data[centerIndex + 0]) {
                anyModified = true;
            }
        }, () => {
            callback(newImageData, anyModified);
        });
    }


    function opening() {
        let windowSize = parseInt(document.getElementById("structuringElementSize").value);
        openingProcessor(windowSize, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            isBinary = isGreyscale = true;  // Image is now binary after morphological processing
            saveOp('Opening ' + windowSize + 'x' + windowSize + '');
            console.log('Was modified? ' + wasModified);
        });
    }

    function openingProcessor(structuringElementSize, imgData, callback) {
        erodeProcessor(structuringElementSize, imgData, (erodedImageData, didErodeModify) => {
            dilateProcessor(structuringElementSize, erodedImageData, (erodeAndDilatedImageData, didDilateModify) => {
                callback(erodeAndDilatedImageData, didErodeModify || didDilateModify);
            })
        });
    }

    function closing() {
        let windowSize = parseInt(document.getElementById("structuringElementSize").value);
        closingProcessor(windowSize, get(), (processedImageData, wasModified) => {
            ctx.putImageData(processedImageData, 0, 0);
            isBinary = isGreyscale = true;  // Image is now binary after morphological processing
            saveOp('Closing ' + windowSize + 'x' + windowSize + '');
            console.log('Was modified? ' + wasModified);
        });
    }

    function closingProcessor(structuringElementSize, imgData, callback) {
        dilateProcessor(structuringElementSize, imgData, (dilatedImageData, didDilateModify) => {
            erodeProcessor(structuringElementSize, dilatedImageData, (dilatedAndErodedImageData, didErodeModify) => {
                callback(dilatedAndErodedImageData, didDilateModify || didErodeModify);
            })
        });
    }

</script>
</body>
</html>
